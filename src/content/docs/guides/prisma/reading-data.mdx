---
title: Reading data
description: Reading data from a database using Prisma and Remix
---

:::danger[Prerequisites]

Make sure that you have completed the lesson on [**seeding data**](/code-monster/guides/prisma/seed-files) before starting this one.

:::

We are now ready to read data from the database using Prisma and Remix. We will start by creating a new route that will display a list of all the articles in the database.

## Start the development server

Start the development server by running the following command in your terminal:

```bash
npm run dev
```

## Create a new route

Create a new file called `articles.tsx` inside the `app/routes` directory.

Add the following code to the file, and save your changes:

```tsx title="app/routes/articles.tsx"
import HomeButton from '~/components/challenges/HomeButton'

function Article() {
	return (
		<div className="flex h-96 w-96 items-center justify-center justify-self-center rounded-xl bg-white/20">
			<p className="text-center text-4xl text-gray-300">Article</p>
		</div>
	)
}

export default function ArticlesRoute() {
	return (
		<main className="min-h-screen">
			<div className="container mx-auto py-28">
				<HomeButton />
				<h1 className="mb-32 text-center text-8xl font-bold text-white">
					Articles
				</h1>

				<div className="grid grid-cols-2 gap-4">
					<Article />
					<Article />
				</div>
			</div>
		</main>
	)
}
```

With your server still running, head back to your browser and navigate to `http://localhost:3000/articles`.

You should see a page with the title "Articles" and two "Article" component placeholders, like this:

![Articles page start](src/assets/png/prisma/articles-page-start.png)

## Fetch data from the database

We now need to fetch the articles from the database and display them on the page.

We will do this by adding a Remix [**loader function**](https://remix.run/docs/en/main/route/loader) to the `articles.tsx` file:

```diff lang="tsx" title="app/routes/articles.tsx"
+import { PrismaClient } from '@prisma/client'
+import { json } from '@remix-run/node'
+import { useLoaderData } from '@remix-run/react'
import HomeButton from '~/components/challenges/HomeButton'

+export async function loader() {
+	const prisma = new PrismaClient()
+
+	const articles = await prisma.article.findMany()
+
+	return json({ articles })
+}

// ...Code omitted for brevity...

export default function ArticlesRoute() {
+	const { articles } = useLoaderData<typeof loader>()
+
+	console.log({ articles })

  // ...Code omitted for brevity...
}
```

::::note[Info]

## What is a `loader` function?

### Client vs. server code

Traditionally, React components are executed in the **client**, or the user's browser. The problem is that user information and other database information can only be accessed on the **server**.

The makers of Remix got around this problem by introducing `loader` functions.

### Accessing server data with `loader` functions

If a `loader` function is exported from a **route** file (i.e. from a `tsx` file placed inside the `routes` folder), then Remix will execute this code on the **server** _before_ the user interface (UI) is rendered. This ensures that any required data is accessed and processed before the UI is presented by the browser.

Look closely at the flow of data in the following diagram:

![Client server side code](src/assets/png/client-server-side-code.png)

In the example shown here, the `loader` function is getting the articles from the database and returning them as JSON data.

This data is then accessed by the `LandingPage` component using the `useLoaderData` hook.

The `articles` are then passed to an `ArticleLinks` component which React renders, along with the rest of the UI, to the user's screen.

:::tip

You can learn more about `loader` functions via the [**Remix docs**](https://remix.run/docs/en/main/route/loader).

:::

::::

In our case, we want to use the `articles` data to render a list of articles on the page. Let's update our code to do this.

## Add props to the `Article` component

### What are props?

In React, **props** are used to pass data from a parent component to a child component. They are read-only and help to make components reusable.

:::tip

You can learn more about props in the [**React docs**](https://react.dev/learn/passing-props-to-a-component).

:::

We will update the `Article` component to accept a `title` prop, and then use this prop to display the article title on screen.

### Define props on a component

Firstly, add the following code to the `Article` component:

```diff title="app/routes/articles.tsx" ins="{ title }: ArticleProps" ins="{title}"
+interface ArticleProps {
+  title: string
+}

function Article({ title }: ArticleProps) {
  return (
    <div className="flex h-96 w-96 items-center justify-center justify-self-center rounded-xl bg-white/20">
      <p className="text-center text-4xl text-gray-300">{title}</p>
    </div>
  )
}
```

:::note[Info]

## What is an `interface`?

### The problem with JavaScript

Imagine that you have an object called `person` that you declare like this:

```javascript
const person = {
  name: 'John',
  age: 30
}
```

Later in your code, you want to display the person's name. You might write something like this:

```javascript
const message = `Hello, ${person.Name}, how are you?`;
```

Take a second and look back at this code. Can you see the problem?

The `person` object doesn't have a `Name` property, it has a `name` property.

This means that the `message` will actually read `Hello, undefined, how are you?`. Definitely not what we wanted!

Unfortunately, if we are coding in JavaScript, this bug will only be discovered at runtime, when the code is executed and already in our customer's browser. This can be a problem, especially in large applications.

### TypeScript to the rescue

To fix this problem, most developers now use TypeScript.

TypeScript is built on top of JavaScript, and lets us annotate code with descriptions of what our variables, objects and functions should look like. This means that we can catch bugs like the one above while we are still coding, long before any customers get to use it.

### Understanding `interfaces`

With objects like the one above, we can declare an `interface` to define a new custom [**type**](https://www.typescripttutorial.net/typescript-tutorial/typescript-types).

In the `person` example, we could define an interface like this:

```typescript
interface Person {
  name: string;
  age: number;
}
```

This means that we can now declare a new `person` object like this:

```typescript ins=": Person"
const person: Person = {
  name: 'John',
  age: 30
}
```

The `: Person` annotation tells TypeScript that the `person` object should have the same properties as the `Person` interface.

Now, if we try to access a `Name` property on the `person` object, TypeScript will throw an error. Our code editor knows in advance that the `person` object should have a property called `name`, not `Name`:

![TypeScript error](src/assets/gif/typescript-error.gif)

This helps TypeScript ensure that data is passed correctly throughout an application, and helps to prevent bugs from occurring.

:::

We've now replaced the hardcoded "Article" placeholder text with the `title` prop. This means that when we pass a `title` prop to the `Article` component, it will display the title on screen.

## Passing props to the `Article` component

If you scroll down to where the `Article` component is called, you will see that TypeScript is angry.

It's telling us that we need to pass a `title` prop to the `Article` component:

![Title prop needed](src/assets/png/prisma/title-prop-needed.png)

Let's fix this by passing the `title` of each `article` to the `Article` component:

```diff title="app/routes/articles.tsx" ins=" title={articles[0].title}" ins=" title={articles[1].title}"
export default function ArticlesRoute() {
	const { articles } = useLoaderData<typeof loader>()

	console.log({ articles })

	return (
		<main className="min-h-screen">
			<div className="container mx-auto py-28">
				<HomeButton />
				<h1 className="mb-32 text-center text-8xl font-bold text-white">
					Articles
				</h1>

				<div className="grid grid-cols-2 gap-4">
					<Article title={articles[0].title} />
					<Article title={articles[1].title} />
				</div>
			</div>
		</main>
	)
}
```
